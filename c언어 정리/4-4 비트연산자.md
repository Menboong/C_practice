# 비트 연산자

- 바이트 단위보다 작은 비트 단위로 연산하는 연산자
  - 1byte = 8bits
  - bit: 2진수를 저장하는 단위로서 컴퓨터에서 사용할 수 있는 최소 단위로 0과 1을 나타냄

| 연산자 | 설명                             |
| ------ | -------------------------------- |
| &      | 비트 AND                         |
| \|     | 비트 OR                          |
| ^      | 비트 XOR                         |
| ~      | 비트 NOT                         |
| <<     | 비트를 왼쪽으로 시프트           |
| >>     | 비트를 오른쪽으로 시프트         |
| &=     | 비트 AND 연산 후 할당            |
| \|=    | 비트 OR 연산 후 할당             |
| ^=     | 비트 XOR 연산 후 할당            |
| <<=    | 비트를 왼쪽으로 시프트 후 할당   |
| >>=    | 비트를 오른쪽으로 시프트 후 할당 |

### flag

- 비트로 옵션을 설정할 때 사용
- 저장 공간을 아낄 수 있는 장점

#### 코드

```c
#include <stdio.h>
 
int main()
{
    unsigned char flag = 0;
 
    flag |= 1;    // 0000 0001 마스크와 비트 OR로 여덟 번째 비트를 켬
    flag |= 2;    // 0000 0010 마스크와 비트 OR로 일곱 번째 비트를 켬
    flag |= 4;    // 0000 0100 마스크와 비트 OR로 여섯 번째 비트를 켬
 
    printf("%u\n", flag);    // 7: 0000 0111
 
    flag &= ~2;  //1111 1101 마스크 값 2의 비트를 뒤집은 뒤 비트 AND로 일곱 번째 비트를 끔
    printf("%u\n", flag);    // 5: 0000 0101
    
    flag = 7; 
    flag ^= 2;    // 0000 0010 마스크와 비트 XOR로 일곱 번째 비트를 토글
    flag ^= 8;    // 0000 1000 마스크와 비트 XOR로 다섯 번째 비트를 토글
    printf("%u\n", flag);    // 13: 0000 1101
    
    if (flag & 1)    // & 연산자로 0000 0001 비트가 켜져 있는지 확인
        printf("0000 0001은 켜져 있음\n");
    else
        printf("0000 0001은 꺼져 있음\n");
    
    return 0;
}
```

- 플래그의 비트를 조작하거나 검사할 때 사용하는 숫자를 마스크라고 함
- 비트 검사 방법
  - if(플래그 & 마스크)
- 비트 켜는 방법
  - 플래그 |= 마스크

![](https://dojang.io/pluginfile.php/247/mod_page/content/32/unit24-9.png)

- 비트 끄는 방법
  - 플래그 &= ~마스크

![](https://dojang.io/pluginfile.php/247/mod_page/content/32/unit24-10.png)

- 비트 토글 방법
  - 플래그 ^= 마스크

![](https://dojang.io/pluginfile.php/247/mod_page/content/32/unit24-11.png)



## AND

- A & B

```C
unsigned char num1 = 1;    // 0000 0001
unsigned char num2 = 3;    // 0000 0011
 
printf("%d\n", num1 & num2);    // 0000 0001: 01과 11을 비트 AND하면 01이 됨
```

### 연산결과

| 비트1 | 비트2 | 결과 |
| ----- | ----- | ---- |
| 0     | 0     | 0    |
| 0     | 1     | 0    |
| 1     | 0     | 0    |
| 1     | 1     | 1    |

- 각 자릿수의 연산은 독립적이며 다른 자릿수에 영향을 주지 않음

```c
0111 1000(120)
0001 1010(26)
_________ &
0001 1000(24)
```

### 연산후 할당

- a &= b

```c
unsigned char n1 = 4;
n1 &= 5; // n1 = 4

n1 = n1 & 5;
```

```c
0000 0100(4)
0000 0101(5)
_________ &
0000 0100(4)
```





## OR

- A | B

```c
unsigned char num1 = 1;    // 0000 0001
unsigned char num2 = 3;    // 0000 0011

printf("%d\n", num1 | num2);    // 0000 0011: 01과 11을 비트 OR하면 11이 됨
```

### 연산결과

| 비트1 | 비트2 | 결과 |
| ----- | ----- | ---- |
| 0     | 0     | 0    |
| 0     | 1     | 1    |
| 1     | 0     | 1    |
| 1     | 1     | 1    |

- 각 자릿수의 연산은 독립적이며 다른 자릿수에 영향을 주지 않음

```c
0000 0001(1)
0000 0011(3)
_________ |
0000 0011(3)
```

### 연산후 할당

- a |= b

```c
unsigned char n1 = 4;
n1 |= 2; // n1 = 6

n1 = n1 | 2;
```

```c
0000 0100(4)
0000 0010(2)
_________ |
0000 0110(6)
```





## NOR

- A ^ B

```C
unsigned char num1 = 1;    // 0000 0001
unsigned char num2 = 3;    // 0000 0011

printf("%d\n", num1 ^ num2);    // 0000 0010: 01과 11을 비트 XOR하면 10이 됨
```

### 연산결과

| 비트1 | 비트2 | 결과 |
| ----- | ----- | ---- |
| 0     | 0     | 0    |
| 0     | 1     | 1    |
| 1     | 0     | 1    |
| 1     | 1     | 0    |

- 각 자릿수의 연산은 독립적이며 다른 자릿수에 영향을 주지 않음

```c
0000 0001(1)
0000 0011(3)
_________ |
0000 0011(3)
```

### 연산후 할당

- a ^= b

```c
unsigned char n1 = 4;
n1 ^= 3; // n1 = 7

n1 = n1 ^ 3;
```

```c
0000 0100(4)
0000 0011(3)
_________ ^
0000 0111(7)
```





## NOT

- "비트를 뒤집는다" 또는 "비트 반전"
- ~A

```C
unsigned char n1 = 162; // 162: 1010 0010
unsigned char n2;

n2 = ~n1; // n2 = 93: 0101 1101 
```

### 연산결과

| 비트1 | 결과 |
| ----- | ---- |
| 0     | 1    |
| 1     | 0    |

```C
1010 0010(162)
_________ ~
0101 1101(93)
```



## 시프트

- 변수 << 이동할 비트수
- 변수 >> 이동할 비트수

```C
unsigned char c1 = 3;
unsigned char c2 = 24;

n1 << 3 // 24: 0001 1000	= n1의 비트값을 왼족으로 3번이동
n2 >> 2 // 3 : 0000 0110	= n2의 비트값을 오른쪽으로 2번이동 
```

![](https://dojang.io/pluginfile.php/237/mod_page/content/23/unit23-3.png)

```c
0000 0011(3)
_________ << 3
0001 1000(24)
```

```c
0001 1000(24)
_________ >> 2
0000 0110(6)
```

- 지정한 횟수대로 비트를 이동시키며 모자라는 공간은 0으로 채운다.
- <<는 2의 거듭제곱을 곱하기
  - 3 << 3 = 3*2의3제곱 = 24
- \>>는 2의 거듭제곱을 나누기
  - 24 >> 2 = 24 / 2의2제곱 = 6

### 연산후 할당

- a <<= b

```c
unsigned char n1 = 4;
n1 <<= 2; // n1 = 16

n1 = n1 << 2;
```

```c
0000 0100(4)
_________ << 2
0001 0000(16)
```

- a >>= b

```c
unsigned char n1 =4;
n1 >>= 2; //n1 = 1

n1 = n1 >> 2;
```

```c
0000 0100(4)
_________ >> 2
0000 0001(1)
```

### 응용

- 2의 거듭제곱을 빠르게 구할 때 유용
  - 비트의 각 자릿수는 2의 거듭제곱을 의미하므로 비트의 이동횟수는 지수와 같음
  - 예를 들면 1 << 3 은 2의 3제곱

### 자릿수를 넘을 때

- 사라진다

```c
1111 0000(240)
_________ << 2
1100 0000(192)
```

```c
0000 1111(15)
_________ >> 2
0000 0011(3)
```

### 부호가 있을 때

![](https://dojang.io/pluginfile.php/246/mod_page/content/22/unit24-2.png)

```c
1000 0011(131)
_________ >> 5
0000 0100(4)
```

```c
1000 0011(-125)
_________ >> 5
1111 1100(-4)
```

![](https://dojang.io/pluginfile.php/246/mod_page/content/22/unit24-3.png)

```c
char n1 = 67;
n2 = n1 >> 5;
```

![](https://dojang.io/pluginfile.php/246/mod_page/content/22/unit24-4.png)

```c
char n1 = 113;
n1 << 2 // -60
```

![](https://dojang.io/pluginfile.php/246/mod_page/content/22/unit24-5.png)

```c
char n1 = -15;
n1 << 2 // 16
```

![](https://dojang.io/pluginfile.php/246/mod_page/content/22/unit24-7.png)

- 부호비트에 위치한 숫자에 따라 양수,음수가 결정되므로 항상 생각하며 고려해야함