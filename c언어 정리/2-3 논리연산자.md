# 논리연산자

| 연산자 | 설명                                   |
| ------ | -------------------------------------- |
| &&     | AND(논리곱), 양쪽 모두 참일때 참       |
| \|\|   | OR(논리합), 양쪽 중 한쪽만 참이라도 참 |
| !      | NOT(논리 부정), 참과 거짓을 뒤집음     |

- 논리값 거짓(FALSE)는 0, 참(TRUE)는 0이 아닌 값이며 보통 1



## AND

```C
A && B
```

- & 기호 하나만 사용하면 AND비트 연산자가 되므로 주의

### 단락평가

- 첫번째 값만으로도 결과가 확실할 때 두 번째값은 확인(평가) 하지 않음
- AND연산자은 두값이 모두 참이여야 참이므로 첫번재 값이 거짓이면 두번재 값은 확인하지 않고 거짓으로 결정



## OR

```C
A || B
```

- | 기호 하나만 사용하면 OR비트 연산자가 되므로 주의
- 두 값 중 하나만 참이라도 결과가 참
- 두 값 중 하나만 참이라도 참이므로 첫번째 값이 참이면 두 번재 값은 확인하지 않고 바로 참으로 결정



## NOT

```C
!A
```

- 값, 변수, 함수 앞에 ! 를 붙여서 사용
- 참은 거짓으로 거짓은 참으로 논리값을 뒤집음
  - 0은 1로 1은 0으로 변경



## 응용

```C
20 > 10 && 30 > 15: 양쪽 모두 참이므로 AND 연산자의 결과는 참
20 > 10 && 30 < 15: 20 > 10만 참이고, 30 < 15는 거짓이므로 AND 연산자의 결과는 거짓
20 > 10 || 30 < 15: 20 > 10이 참이므로 OR 연산자의 결과는 참
20 < 10 || 30 < 15: 양쪽 모두 거짓이므로 OR 연산자의 결과는 거짓
!(20 > 10): 참을 NOT 연산자로 뒤집었으므로 결과는 거짓
```

- 비교연산자와 논리 연산자가 연달아서 나오면 알아보기 힘들기 때문에 괄호를 사용하여 의도 명확하게 나타내기

```C
printf("%d\n", (num1 > num2) && (num3 > num4));
printf("%d\n", (num1 > num2) && (num3 < num4));

printf("%d\n", (num1 > num2) || (num3 < num4));
printf("%d\n", (num1 < num2) || (num3 < num4));
```

### 조건문

```C
int num1 = 1;
    int num2 = 0;
 
    if (num1 && num2)      // num1과 num2가 모두 참인지 검사
        printf("참\n");
    else
        printf("거짓\n");  // num1만 참이므로 거짓이 출력됨
 
    if (num1 || num2)      // num1과 num2 둘 줄 하나가 참인지 검사
        printf("참\n");    // num1이 참이므로 참이 출력됨
    else
        printf("거짓\n");
 
    if (!num1)             // num1을 반대로 뒤집음
        printf("참\n");
    else
        printf("거짓\n");  // 참을 뒤집었으므로 거짓이 출력됨
 
```

### 삼항연산자

```c
int num1 = 1;
int num2 = 0;
 
printf("%s\n", num1 && num2 ? "참" : "거짓");    // 거짓: 삼항 연산자에서 AND 연산자 사용
printf("%s\n", num1 || num2 ? "참" : "거짓");    // 참: 삼항 연산자에서 OR 연산자 사용
```





## 단락평가 활용

```C
int num1 = 0;
int num2 = 10;

if ((num1 != 0) && (num2 / num1) < 20)    // num1이 0이면 나눗셈 연산을 하지 않음.
    printf("참\n");
else
    printf("거짓\n");
```

- 정수를 0으로 나누면 에러가 발생하지만 나눗셈 연산 전에 (num1 != 0) &&와 같이 num1이 0인지 검사하면 에러를 예방

  - 즉, && 연산자에서 첫번째 조건이 만족하지 않으면 두 번째 조건은 검사하지 않는 특성을 이용

  - 단락 평가는 논리 연산자로 된 조건 검사뿐만 아니라 사칙 연산 수행에도 적용됩니다.